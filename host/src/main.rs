use std::{
    fs::File,
    io::{BufReader, Read},
    time::Instant,
};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{
    default_prover, get_prover_server, ExecutorEnv, InnerReceipt, Journal, ProverOpts, Receipt,
};

// Has to match value inside methods/guest/src/main.rs
const INPUT_CHUNK_MAX_SIZE: usize = 513;

fn print_help_and_exit(name: &str) -> ! {
    eprintln!("Usage: {} prove input_file output_receipt_file", name);
    eprintln!("Usage: {} verify receipt_file", name);
    eprintln!(
        "Usage: {} compress input_receipt_file output_receipt_file",
        name
    );
    std::process::exit(1);
}

fn print_journal(journal: &Journal) {
    println!("Input hash:  {}", hex::encode(&journal.bytes[0..32]));
    println!("Output hash: {}", hex::encode(&journal.bytes[32..64]));
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let mut env_builder = ExecutorEnv::builder();

    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2 {
        print_help_and_exit(&args[0]);
    }

    match args[1].as_str() {
        "verify" => {
            if args.len() != 3 {
                print_help_and_exit(&args[0]);
            }
            let receipt_file = File::open(&args[2]).unwrap();
            let receipt: risc0_zkvm::Receipt = bincode::deserialize_from(receipt_file).unwrap();
            receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap();
            println!("Verified receipt.");
            print_journal(&receipt.journal);
        }
        "prove" => {
            if args.len() != 4 {
                print_help_and_exit(&args[0]);
            }
            let input_file = File::open(&args[2]).unwrap();
            let mut reader = BufReader::new(input_file);
            let mut input = Vec::new();
            reader.read_to_end(&mut input).unwrap();

            for chunk in input.chunks(INPUT_CHUNK_MAX_SIZE) {
                env_builder.write::<u16>(&(chunk.len() as u16)).unwrap();
                env_builder.write_slice(chunk);
            }
            env_builder.write::<u16>(&0).unwrap();

            let env = env_builder.build().unwrap();

            // Obtain the default prover.
            let prover = default_prover();

            // Produce a receipt by proving the specified ELF binary.
            let start = Instant::now();
            let receipt = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap();
            let duration = start.elapsed();

            println!("Created proof in {:?}", duration);

            print_journal(&receipt.journal);

            let mut output_receipt_file = File::create(&args[3]).unwrap();
            bincode::serialize_into(&mut output_receipt_file, &receipt).unwrap();
            println!("Receipt written to {}", &args[3]);
        }
        "compress" => {
            if args.len() != 4 {
                print_help_and_exit(&args[0]);
            }
            let receipt_file = File::open(&args[2]).unwrap();
            let receipt: risc0_zkvm::Receipt = bincode::deserialize_from(receipt_file).unwrap();

            let composite_receipt = receipt.inner.composite().expect(
                "Only composite receipts generated by the prove subcommand can be compressed.",
            );

            // TODO after https://github.com/risc0/risc0/pull/1518, go back to using
            // default_prover() and remove the "risc0-zkvm/prove" feature in Cargo.toml.
            let opts = ProverOpts::default();
            let prover = get_prover_server(&opts).unwrap();

            let start = Instant::now();
            let succinct_receipt = prover.compress(&composite_receipt).unwrap();
            let duration = start.elapsed();

            println!("Compressed proof in {:?}", duration);

            let output_receipt = Receipt::new(
                InnerReceipt::Succinct(succinct_receipt),
                receipt.journal.bytes,
            );

            let mut output_receipt_file = File::create(&args[3]).unwrap();
            bincode::serialize_into(&mut output_receipt_file, &output_receipt).unwrap();
            println!("Succinct receipt written to {}", &args[3]);
        }
        _ => {
            print_help_and_exit(&args[0]);
        }
    }
}
